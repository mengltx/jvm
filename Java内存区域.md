### 运行时数据区域

java虚拟机管理的内存包括以下几个运行时数据区域,如下图所示

<img src="/Users/zhangdongdong/Library/Application Support/typora-user-images/image-20200419174955996.png" alt="image-20200419174955996" style="zoom:50%;" />

#### 程序计数器

​		程序计数器是一块比较小的内存区域,可以看做当前线程执行的字节码的行号指示器,在java虚拟机的概念模型里,字节码解释器工作时就是改变这个计数器的值来选取下一条需要执行的字节码指令,它是程序控制流的指示器,分支,循环,跳转,异常处理,线程恢复等基础功能都要依赖这个计数器完成.

​		由于java虚拟机的多线程是通过线程轮流切换,分配处理器执行时间的方式实现的,在任何一个时刻,一个处理器(或者说内核)只是执行一个线程中的指令,因此,为了线程切换后能回复到正确的执行位置,每个线程都需要一个独立的程序计数器.所以程序计数器是线程私有的.

​		如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的字节码的指令的地址.如果正在执行一个本地(Native)方法,这个计数器的值应为空(Undefined).这个区域是<<java虚拟机规范>>中没有规定OutOfMemoryError情况的区域.



#### Java虚拟机栈

​		和程序计数器一样,Java虚拟机栈(Java VM Stack)也是线程私有的.它的生命周期	和线程相同.Java虚拟机栈描述的是Java方法执行的内存模型,每个方法执行的时候,虚拟机会同步创建一个栈帧用来存储局部变量表,操作数栈,动态链接,方法出口等信息.每个方法被调用直至执行完毕的过程,对应一个栈帧入栈到出栈的过程.

​		局部变量表存储了方法的参数和局部变量.在编译期就知道局部变量表要分配的最大内容,就在方法的Code属性的max_locals中,局部变量表存储数据的类型有基本数据类型(boolean,byte,char,int,short,float,long,double),对象引用(reference类型)和returnAddress类型(指向一条字节码指令的地址).局部变量表的最小单位是槽(Slot),其中long和doule类型占据两个变量槽,其他类型占据一个.Slot的大小可以是32字节,64字节或者更多.

​		局部变量表需要的内存空间在编译时就能确定,局部变量表的大小指的是Slot的数量.

​		在<<Java 虚拟机规范>>中,对这个内存区域指定了两类异常情况.如果线程请求的栈深度大于大于虚拟机所允许的深度,将抛出StackOverFlowError,如果虚拟机栈的容量可以动态拓展,当栈拓展时无法申请到足够的内存会抛出OutOfMemoryError异常.

#### 本地方法栈

​		本地方法栈和虚拟机栈发挥的作用是非常相似的,区别是虚拟机栈为虚拟机执行Java方法(字节码)服务,本地方法是为虚拟机执行本地(Native)方法.

​	<<Java 虚拟机规范>>对本地方法栈使用的语言,使用的方式与数据结构没有什么强制的规定,因此虚拟机可以根据需要自由实现,甚至有的Java虚拟机(hotpot)直接就把本地方法栈和虚拟机栈二合一.与虚拟机栈一样,本地方法栈也会在栈深度溢出和动态拓展时无法申请到足够的内存时分别抛出StackOverFlowError和OutOfMemoryError.



#### Java堆

​		对于Java应用程序来说,Java堆(Heap)是Java虚拟机所管理的最大的一块内存.被所有的线程锁共享,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例,Java世界里几乎所有的对象实例都会在堆这里分配内存.<<Java 虚拟机规范>>中对Java堆的描述是:`所有对象实例和数组都应当在堆上分配`.但是由于技术的发展这句话已经不那么绝对了.

​		从内存管理的角度,所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区(Thread Local Allocate Buffer,TLAB),用来提升对象的分配效率.不过无论从什么角度,无论如何划分都不会改变Java堆中存储内容的共性,存储的都是对象的实例.将java堆细分的目的只是为了更好的回收.

​	Java堆不要求在物理上初一连续的内存空间中,但是在逻辑上应该被视为是连续的.Java堆可以被实现为固定大小也可以是可拓展的.主流的虚拟机都是按照可拓展来实现的(通过-Xmx和-Xms设定).若果Java堆没有完成内存分配并且堆也无法再拓展时,虚拟机会抛出OutOfMemoryError.

#### 方法区

​	方法区和Java堆一样,都是各个线程共享的一块区域.他存储了一下内容

		+ 类型信息常量
		+ 静态变量
		+ 即时编译器编译后的代码缓存



​		<<Java 虚拟机规范>>把方法区描述为堆的一个逻辑部分.但是它有个别名叫做非堆(Non-Heap),目的是与Java堆区分开这里要提一下永久代.在JDK8之前很多人愿意吧方法区叫做永久代(Permanent Generation)或者将两者混为一谈,其实两者并不是等价的,这是因为当时的HotSpot团队把收集器分代设计拓展至方法区.或者说用永久代来实现方法区,省去专门为方法区编写内存管理代码的工作.但是其他的虚拟机实现(比如BEA JRockit,IBM J9)来说是没有永久代的概念的.当然HotSpot团队也认识到这样设计的弊端的,因此在JDK7的时候把原本放在永久代的字符串常量池和静态变量移出了.到了JDK8 的时候完全废弃了永久代的概念,使用了元空间(Metaspace)来代替.

<<Java 虚拟机规范>>对方法区的约束是比较松的,除了和java堆一样不需要连续的内存区域和可以选择固定大小或者可拓展之外,甚至可以选择不实现垃圾收集.方法区回收的目标主要针对常量的回收和类型的卸载.

<<Java 虚拟机规范>>规定,如果方法区无法满足新的内存的分配需求时,将抛出OutOfMemoryError.



#### 运行时常量池

​		运行时常量池(Runtime Constant Pool)是方法区的一部分,Class文件中除了有类的版本,字段,方法,接口等描述信息时外,还有一项信息是常量池表,用于存放编译期生成的各种字面量和符号引用.这部分内容将在类加载后存放到方法区的运行时常量池中.



#### 直接内存

​		直接内存并不是虚拟机运行时内存区域的一部分.也没有在<<ava 虚拟机规范>>中定义,但是这部分内存也被频繁的使用,也有可能导致OOM异常的出现.

​		NIO引入了一种基于通道和缓冲区的IO方式,它可以使用Native函数库直接分配的堆外内存,然后通过一个存储在Java堆中DirectByteBuffer对象作为这块内存的引用进行操作.这样能在一些场景中显著提高性能,因为避免了Java堆和Native堆之间来回复制数据.

​		直接内存的分配不会受到Java堆大小的限制,但是会受到内存







​	

​		

